---
title: "Proyecto Final"
author: "Guillermo Pinto, Carlos García, Jesús Ramírez"
date: "2023-12-02"
output:         
    html_document:      
        code_folding: hide      
editor_options: 
  markdown: 
    wrap: 72
encoding: UTF-8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# Pruebas Icfes Saber 11 del segundo semestre del año 2022 {.tabset}

## Introducción

En el contexto educativo actual, comprender los factores que influyen en el rendimiento académico de los estudiantes es fundamental. Por ello, el objetivo de este proyecto es investigar y analizar en profundidad los determinantes detrás de los resultados obtenidos en las pruebas Saber 11. Para ello, se estudia un conjunto de datos que contiene información general distribuida en cuatro categorías principales: estudiante, familia, colegio y aspectos relacionados con la prueba. Los análisis se realizarán a través de Rstudio, utilizando técnicas estadísticas y demográficas como la correlación de variables para describir relaciones entre columnas, así como análisis de gráficos y un análisis espacial. Es importante señalar que el examen Saber 11 es un referente clave en la evaluación del sistema educativo colombiano. Por lo tanto, explorar los elementos que impactan sus resultados puede ofrecer valiosas perspectivas para mejorar el proceso educativo.


## Paquetes requeridos 

Para reproducir el código y los resultados a lo largo de este proyecto, fue necesario cargar los siguientes paquetes.

- **knitr:** Se utiliza para mostrar una tabla alineada en la pantalla.
- **DT**: Usado para presentar datos en formato desplazable y ordenable.
- **ggplot2**: Usada para crear visualizaciones gráficas a partir de datos.
- **sf**: Usada para el manejo de datos geoespaciales.
- **dplyr**: Usada para la manipulación de datos y operaciones JOIN.
- **tmap**: Usada para representar mapas geográficos.
- **reshape2**: Usada para reorganizar y transformar datos.
- **tidyr**: Usada para ajustar la estructura de los datos para análisis.

``` {r packages, eval= TRUE}
library(knitr)
library(DT)
library(ggplot2) 
library(dplyr)
library(sf) 
library(dplyr) 
library(tmap) 
library(reshape2)
library(tidyr)
```


## Preparación de datos {.tabset .tabset-fade}

### Importación de datos

#### Resultados anonimizados de las pruebas Icfes Saber 11 del segundo semestre del año 2022.

El propósito original de los datos es proporcionar información valiosa y
oportuna sobre estudiantes que participan en las pruebas Saber,
incluyendo sus resultados académicos y datos socioeconómicos. Estos
datos, publicados por el Instituto Colombiano para la Evaluación de la
Educación (Icfes) en el repositorio DataIcfes, buscan contribuir al
mejoramiento de la calidad educativa en Colombia al ofrecer información
confiable y pertinente para análisis e investigaciones que incidan
positivamente en el sistema educativo del país.

Los datos se recopilan principalmente el día que los estudiantes
presentan la prueba. A partir de las respuestas proporcionadas en el
cuestionario sociodemográfico y las cinco pruebas en cada área del
conocimiento, se recopila información personal, de contacto, familiar,
así como datos del colegio y de citación. Los resultados, que incluyen
puntajes, percentiles y niveles socioeconómicos, se calculan con base en
los datos recolectados durante la presentación de las pruebas.

Este conjunto de datos abarca 82 variables que capturan una amplia gama
de factores socioeconómicos, demográficos y académicos a lo largo de
532,792 registros. Proporciona información sobre el rendimiento
académico, antecedentes familiares, instituciones educativas y puntajes
de pruebas entre estudiantes, cubriendo una amplia gama de contextos
socioeducativos. Además, ofrece información detallada sobre ubicaciones
geográficas, distribución de género y acceso a recursos dentro de
diversas comunidades.

Se puede incontrar más información sobre el conjunto de datos en la
página del Instituto Colombiano para la Evaluación de la Educación -
ICFES (2023). *DataIcfes. Saber 11.*
<https://www.icfes.gov.co/web/guest/data-icfes>

Nuestra exploración de datos inició con la tabla inicial provista por
[Datos.gov.co](https://www.datos.gov.co/Educaci-n/Saber-11-2019-2/ynam-yc42#),
revelando una estructura compleja y columnas poco claras. Accedimos al
diccionario de datos a través de DataIcfes, una base independiente del
Icfes. Tras solicitar acceso, encontramos información extensa sobre
pruebas Saber 11 desde 2001 hasta 2022 y escogimos los datos más
actualizados. A pesar de intentos fallidos de importar archivos .txt en
R debido al separador '¬', optamos por LibreOffice Calc para
convertirlos a CSV con separador ','. Posteriormente, logramos importar
con éxito en R usando read.csv, facilitando nuestro análisis.

```{r import_data}
ruta_datos <- "SB11_20222.csv"
data <- read.csv(ruta_datos, sep = ",", dec = ".", header = TRUE, stringsAsFactors = TRUE)

# Verificar la clase del objeto
class(data)
# Ver los nombres de las columnas
colnames(data)
# Contar la cantidad de registros y columnas
dim(data)
```

### Limpieza de datos

#### Datos irrelevantes

La limpieza de datos es crucial para garantizar la precisión y
coherencia en el análisis. Nuestro proceso de limpieza se basó en pasos
lógicos y específicos. Primero, identificamos columnas irrelevantes para
nuestro análisis, eliminándolas para focalizarnos en datos pertinentes.

Las columnas eliminadas abarcaban detalles específicos y contextuales
poco relevantes para nuestro análisis. Incluían información sobre la
estructura familiar, ocupación de los padres, alimentación y cantidad de 
habitaciones en el hogar, así como datos relacionados con el tipo de documento,
nacionalidad, género, período de presentación del examen, entre otros.

Estos detalles, aunque podrían ser importantes en otros contextos, no
aportaban directamente a nuestras investigaciones sobre la correlación
entre variables socioeconómicas, demográficas y el rendimiento académico. 
Su exclusión nos permitió concentrarnos en datos más pertinentes y directamente
vinculados a nuestras áreas de estudio, optimizando así la calidad y relevancia
de nuestro análisis.

```{r clean_data}
columnas_relevantes <- c(
    "ESTU_NSE_INDIVIDUAL", "PUNT_GLOBAL", "FAMI_TIENECOMPUTADOR",
    "FAMI_ESTRATOVIVIENDA", "COLE_NATURALEZA",
    "ESTU_DEDICACIONLECTURADIARIA", "ESTU_HORASSEMANATRABAJA",
    "ESTU_TIPOREMUNERACION", "FAMI_EDUCACIONPADRE", "FAMI_EDUCACIONMADRE", 
    "FAMI_NUMLIBROS", "FAMI_TIENEINTERNET", "ESTU_DEDICACIONINTERNET", 
    "DESEMP_LECTURA_CRITICA", "DESEMP_MATEMATICAS", "PUNT_INGLES", 
    "DESEMP_C_NATURALES", "DESEMP_SOCIALES_CIUDADANAS", "PUNT_LECTURA_CRITICA",
    "PUNT_MATEMATICAS", "PUNT_C_NATURALES", "PUNT_SOCIALES_CIUDADANAS",
    "ESTU_COD_RESIDE_DEPTO", "ESTU_COD_RESIDE_MCPIO", "COLE_AREA_UBICACION"
)

data <- data[, columnas_relevantes, drop = FALSE]
```

___

Después de la limpieza de datos, volvemos a comprobar el número de filas
y columnas, como se muestra en el siguiente código.

```{r size_clean_data}
# Contar la cantidad de registros y columnas
dim(data)
```

___

#### Missing values

Iniciamos nuestro análisis tratando valores 'NA' o vacíos de manera general, lo
que resultó en la pérdida de 25K de registros, reduciendo el conjunto a más de
507K de registros para el análisis exploratorio. Aunque significativo, este
enfoque nos brindó una visión inicial de la integridad de nuestros datos.

Posteriormente, ajustamos nuestra estrategia. Optamos por eliminar 'NA' de
manera específica en columnas clave para ciertas preguntas analíticas, como en
la matriz de correlación. Este enfoque nos permitió realizar tratamientos más
precisos en los datos relevantes sin comprometer la integridad global del conjunto.

Esta metodología dual nos ha permitido mantener un tamaño de muestra
representativo y relevante para nuestros análisis generales, al tiempo que
garantiza un tratamiento más específico y detallado donde es necesario. Esta
aproximación se alinea con nuestro objetivo de mantener datos precisos y
completos, asegurando que nuestras interpretaciones sean fundamentadas y confiables.

```{r missing_values}
# Contar la cantidad de NA
sum(is.na(data))

data <- data[complete.cases(data), ] # Quitar los NA del nuevo dataframe

sum(is.na(data))
```

### Previsualización de datos

#### Vista previa del conjunto de datos limpio

En los datos, cada fila es un estudiante y las columnas son la
información socioeconómica, demográfica, académica,  y familiar de la
prueba sobre el estudiante.

```{r prev_data}
library(DT)
datatable(head(data[, 1:10],50))
```

### Descripción de datos

```{r data_desc}
Variable.type <- lapply(data,class)
Variable.desc <- c(
    "Nivel Socioeconómico del evaluado",
    "Puntaje total obtenido",
    "¿Cuáles de los siguientes bienes posee su hogar?: Computador",
    "Estrato socioeconómico de la vivienda según recibo de energía eléctrica",
    "Indica la naturaleza del Establecimiento (Privado o público)",
    "Usualmente, ¿cuánto tiempo al día dedica a leer por entretenimiento?",
    "¿Cuántas horas trabajó usted durante la semana pasada?",
    "Tipo de remuneración por trabajar",
    "Nivel educativo más alto alcanzado por el padre",
    "Nivel educativo más alto alcanzado por la madre",
    "¿Cuántos libros físicos o electrónicos hay en su hogar excluyendo periódicos, revistas, directorios telefónicos y libros del colegio?",
    "¿Su hogar cuenta con servicio o conexión a internet?",
    "Usualmente, ¿cuánto tiempo al día dedica a navegar en internet? Excluya actividades académicas",
    "Desempeño en lectura crítica",
    "Desempeño matemáticas",
    "Puntaje en inglés",
    "Desempeño ciencias naturales",
    "Desempeño sociales y ciudadanas",
    "Puntaje en lectura crítica",
    "Puntaje en matemáticas",
    "Puntaje en ciencias naturales",
    "Puntaje sociales y ciudadanas",
    "Código Dane del departamento de residencia",
    "Código Dane del municipio de residencia",
    "Área de ubicación de la Sede (rural o urbano)"
)

data.desc <- data.frame(
    Data.Type = unlist(Variable.type), 
    Descipcion.Variable = Variable.desc,
    row.names = names(Variable.type)
)

library(knitr)
kable(data.desc, caption = "Diccionario de Datos")
```


## Análisis exploratorio {.tabset .tabset-fade}
### Matriz de correlación

Este código realiza la conversión de variables categóricas (factores) a numéricas, simplificando las etiquetas para mejorar la legibilidad y permitir el análisis estadístico.

Primero, identifico los niveles de las variables categóricas a convertir, mostrándolos para su inspección. Luego, reordeno estos niveles para asignarles un orden lógico, donde los valores inferiores tienen asignados números menores. Por ejemplo, en la variable de estrato socioeconómico, se asigna el número 1 al estrato más bajo y así sucesivamente. 

```{r factor_to_numeric}
# Conversión de variables factoriales a numéricas

## Primero se ven los niveles que tiene la variable
levels(data$FAMI_ESTRATOVIVIENDA)

## Luego se ordenan los niveles de menor a mayor
data$FAMI_ESTRATOVIVIENDA <- factor(data$FAMI_ESTRATOVIVIENDA, levels = c("Sin Estrato", "Estrato 1", "Estrato 2", "Estrato 3", "Estrato 4", "Estrato 5", "Estrato 6"))

## Se verifica
levels(data$FAMI_ESTRATOVIVIENDA)

## Se convierte a numero, donde 1 es el nivel inferior, así sucesivamente
data$FAMI_ESTRATOVIVIENDA <- as.numeric(data$FAMI_ESTRATOVIVIENDA)
```

Esto se hace para variables como dedicación diaria a la lectura, horas de trabajo, nivel educativo de los padres, número de libros en el hogar y tiempo de dedicación a internet.

```{r factor_to_numeric_resto, echo = TRUE, collapse = TRUE}
### Para tiempo de lectura diaria por entretenimiento
#levels(data$ESTU_DEDICACIONLECTURADIARIA)
data$ESTU_DEDICACIONLECTURADIARIA <- factor(data$ESTU_DEDICACIONLECTURADIARIA, levels = c("No leo por entretenimiento", "30 minutos o menos", "Entre 1 y 2 horas", "Entre 30 y 60 minutos", "Más de 2 horas"))
#levels(data$ESTU_DEDICACIONLECTURADIARIA)
data$ESTU_DEDICACIONLECTURADIARIA <- as.numeric(data$ESTU_DEDICACIONLECTURADIARIA)

### Para horas que trabaja
#levels(data$ESTU_HORASSEMANATRABAJA)
data$ESTU_HORASSEMANATRABAJA <- factor(data$ESTU_HORASSEMANATRABAJA, levels = c("0", "Menos de 10 horas", "Entre 11 y 20 horas", "Entre 21 y 30 horas", "Más de 30 horas"))
#levels(data$ESTU_HORASSEMANATRABAJA)
data$ESTU_HORASSEMANATRABAJA <- as.numeric(data$ESTU_HORASSEMANATRABAJA)

### Para educacion madre
#levels(data$FAMI_EDUCACIONMADRE)
data$FAMI_EDUCACIONMADRE <- factor(data$FAMI_EDUCACIONMADRE, levels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))
#levels(data$FAMI_EDUCACIONMADRE)
data$FAMI_EDUCACIONMADRE <- as.numeric(data$FAMI_EDUCACIONMADRE)

### Para educacion padre
#levels(data$FAMI_EDUCACIONPADRE)
data$FAMI_EDUCACIONPADRE <- factor(data$FAMI_EDUCACIONPADRE, levels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))
#levels(data$FAMI_EDUCACIONPADRE)
data$FAMI_EDUCACIONPADRE <- as.numeric(data$FAMI_EDUCACIONPADRE)

### Para numero de libros
#levels(data$FAMI_NUMLIBROS)
data$FAMI_NUMLIBROS <- factor(data$FAMI_NUMLIBROS, levels = c("0 A 10 LIBROS", "11 A 25 LIBROS", "26 A 100 LIBROS", "MÁS DE 100 LIBROS"))
#levels(data$FAMI_NUMLIBROS)
data$FAMI_NUMLIBROS <- as.numeric(data$FAMI_NUMLIBROS)

### Para tiempo de dedicacion internet
#levels(data$ESTU_DEDICACIONINTERNET)
data$ESTU_DEDICACIONINTERNET <- factor(data$ESTU_DEDICACIONINTERNET, levels = c("No Navega Internet", "30 minutos o menos", "Entre 1 y 3 horas", "Más de 3 horas"))
#levels(data$ESTU_DEDICACIONINTERNET)
data$ESTU_DEDICACIONINTERNET <- as.numeric(data$ESTU_DEDICACIONINTERNET)

### Para tipo de remuneracion
#levels(data$ESTU_TIPOREMUNERACION)
data$ESTU_TIPOREMUNERACION <- factor(data$ESTU_TIPOREMUNERACION, levels = c("No", "Si, en efectivo", "Si, en efectivo y especie", "Si, en especie"))
#levels(data$ESTU_TIPOREMUNERACION)
data$ESTU_TIPOREMUNERACION <- as.numeric(data$ESTU_TIPOREMUNERACION)
```

Después de la conversión, creé un nuevo dataframe que incluye estas variables numéricas junto con otras variables relevantes como puntajes globales, desempeño en inglés, lectura crítica, matemáticas, ciencias y sociales. Además, se verifico y corrijo la presencia de valores perdidos (NA) en el nuevo dataframe, eliminándolos para garantizar una análisis robusto.

```{r cor_matrix}
matrix_df <- data[, c("FAMI_ESTRATOVIVIENDA", "ESTU_DEDICACIONLECTURADIARIA", "ESTU_HORASSEMANATRABAJA", "FAMI_EDUCACIONMADRE", "FAMI_EDUCACIONPADRE", "FAMI_NUMLIBROS", "ESTU_DEDICACIONINTERNET",  "ESTU_NSE_INDIVIDUAL", "ESTU_TIPOREMUNERACION","PUNT_GLOBAL", "PUNT_INGLES", "DESEMP_LECTURA_CRITICA", "DESEMP_MATEMATICAS", "DESEMP_C_NATURALES", "DESEMP_SOCIALES_CIUDADANAS")]

sum(is.na(matrix_df)) # Contar los NA

matrix_df <- matrix_df[complete.cases(matrix_df), ] # Quitar los NA del nuevo dataframe

# Cambiar los nombres de las columnas para una matrix más legible
colnames(matrix_df) <- c("estrato", "lectura_diaria", "horas_trabajo", "educacion_madre", "educacion_padre", "num_libros", "dedicacion_internet", "nivel_socioeconomico", "tipo_remuneracion","punt_global", "punt_ingles", "desempenio_lectura", "desempenio_mate", "desempenio_ciencias", "desempenio_sociales")

correlation_matrix <- cor(matrix_df)

# Generar el gráfico sin valores de correlación
corrplot::corrplot(correlation_matrix, type = "lower", tl.cex=0.7)
```

#### Qué se observa

- Se evidencia que la educación de los padres tiende a ser mayor conforme el estrato y que eso mismo se ve reflejados en puntajes un poco más altos de forma global y más específicamente en un mayor puntaje en inglés.
- Sacar más puntaje en un área específica tiene una correlación directa con sacar más puntaje en las demás áreas y sobre todo en el puntaje global como es obvio.
- Se observa una leve correlación entre la cantidad de libros y el puntaje. Aunque entre la cantidad de libros y la dedicación a leer no. Es extraño.

### Análisis socioeconómico {.tabset}

Se analiza la correlación entre varias variables, como el nivel socieconomico, el tipo de colegio (público/privado) o (bilingüe/no bilingüe), tiempo de dedicación a la lectura, el nivel educativo de los padres y el puntaje obtenido por los estudiantes.

#### Nivel socioeconómico 

Analizamos si existe una correlación entre el desempeño académico y el nivel socioeconómico del estudiante.

Para ello, lo primero que debemos hacer es crear un dataframe con las dos variables a analizar en este caso: "ESTU_NSE_INDIVIDUAL" y "PUNT_GLOBAL":

```{r c_des_nse}
des_nse_df <- data[, c("ESTU_NSE_INDIVIDUAL", "PUNT_GLOBAL")] # Crear un nuevo dataframe con las dos columnas de interés

# Calcular correlación entre las dos variables
correlation_value <- cor(des_nse_df$ESTU_NSE_INDIVIDUAL, des_nse_df$PUNT_GLOBAL)
# Imprimir el valor de correlación
print(paste("La correlación entre NSE e PUNT_GLOBAL es:", round(correlation_value, 3)))
```
 Seguido de esto procedemos a realizar un histograma entre las dos variables, para analizar tendencias a partir del mismo: 
 
```{r c_des_nse_2}
# Gráfico combinado con líneas de densidad ajustadas por clase socioeconómica
ggplot(data, aes(x = PUNT_GLOBAL, fill = as.factor(ESTU_NSE_INDIVIDUAL))) +
  geom_density(alpha = 0.6, adjust = 1) +
  labs(title = "Distribución de puntajes por nivel socioeconómico", x = "Puntaje global", y = "Densidad") +
  scale_fill_discrete(name = "Nivel socioeconómico") +
  theme_minimal()
```

Del cual podemos concluir que


#### Tipo de colegio

Analizamos si el tipo de colegio (público/privado, bilingüe/no bilingüe) se correlaciona con el desempeño académico 

¿Los estudiantes de ciertos tipos de colegios tienen ventajas o desventajas en sus puntajes?

```{r c_des_tc}
# Calcular el promedio de puntajes por tipo de colegio
promedios <- data %>%
  group_by(COLE_NATURALEZA) %>%
  summarise(
    Promedio_Lectura = mean(PUNT_LECTURA_CRITICA),
    Promedio_Matematicas = mean(PUNT_MATEMATICAS),
    Promedio_Ciencias = mean(PUNT_C_NATURALES),
    Promedio_Ingles = mean(PUNT_INGLES),
    Promedio_Sociales = mean(PUNT_SOCIALES_CIUDADANAS)
  )

# Reorganizar los datos para el gráfico de barras apiladas
stacked_data <- promedios %>%
  pivot_longer(cols = starts_with("Promedio"), names_to = "Area", values_to = "Promedio")

# Crear el gráfico de barras apiladas
ggplot(stacked_data, aes(x = COLE_NATURALEZA, y = Promedio, fill = Area)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = round(Promedio, 2)), 
            position = position_stack(vjust = 0.5), 
            color = "white", size = 4) +
  labs(title = "Desempeño promedio por área y tipo de colegio",
       x = "Tipo de colegio",
       y = "Puntaje promedio") +
  theme_minimal() +
  theme(legend.position = "right")

```


#### Nivel educativo de los padres

¿Los hijos de padres con niveles educativos más altos tienden a obtener mejores puntajes en las pruebas?

```{r c_des_ne}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$educacion_padre <- factor(matrix_df$educacion_padre, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                                   labels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

matrix_df$educacion_madre <- factor(matrix_df$educacion_madre, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                                   labels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

# Combinar las columnas en una sola para el gráfico
combined_df <- matrix_df %>%
  gather(key = "tipo_educacion", value = "nivel_educacion", educacion_padre, educacion_madre)

# Reordenar niveles de la columna 'nivel_educacion'
combined_df$nivel_educacion <- factor(combined_df$nivel_educacion,
                                      levels = c("Ninguno", "Primaria incompleta", "Primaria completa",
                                                 "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa",
                                                 "Técnica o tecnológica incompleta", "Técnica o tecnológica completa",
                                                 "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

# Crear el gráfico de caja
ggplot(combined_df, aes(x = nivel_educacion, y = punt_global, fill = tipo_educacion)) +
  geom_boxplot() +
  labs(title = "Relación entre educación de los padres y puntaje global",
       x = "Nivel de educación",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

```




### Acceso a recursos {.tabset}

#### Computador

```{r cor_tienepc_punt}
# Crear un nuevo dataframe con un índice para representar a los estudiantes
data$indice <- seq_along(data$PUNT_GLOBAL)

# Filtrar datos para quienes tienen y no tienen computadora
con_computadora <- data[data$FAMI_TIENECOMPUTADOR == "Si", ]
sin_computadora <- data[data$FAMI_TIENECOMPUTADOR == "No", ]

# Unir ambos datasets
combined_data <- rbind(
  data.frame(TieneComputadora = "Sí", PUNT_GLOBAL = con_computadora$PUNT_GLOBAL),
  data.frame(TieneComputadora = "No", PUNT_GLOBAL = sin_computadora$PUNT_GLOBAL)
)

# Graficar los puntajes de los dos grupos en un solo gráfico de caja
ggplot(combined_data, aes(x = TieneComputadora, y = PUNT_GLOBAL, fill = TieneComputadora)) +
  geom_boxplot() +
  labs(title = "Puntajes según el acceso a un computador",
       x = "Tiene computador",
       y = "Puntaje global") +
  theme_minimal()

# Calcular correlación entre puntajes y tener computadora
correlacion_con <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENECOMPUTADOR == "Si"))

# Calcular correlación entre puntajes y tener computadora
correlacion_sin <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENECOMPUTADOR == "No"))

# Mostrar la correlación
cat("La correlación entre tener computador y el puntaje es:", correlacion_con)

cat("La correlación entre no tener computador y el puntaje es:", correlacion_sin)
```

#### Internet

```{r c_internet_des}
# Crear un nuevo dataframe con un índice para representar a los estudiantes
data$indice <- seq_along(data$PUNT_GLOBAL)

# Filtrar datos para quienes tienen y no tienen computadora
con_computadora <- data[data$FAMI_TIENEINTERNET == "Si", ]
sin_computadora <- data[data$FAMI_TIENEINTERNET == "No", ]

# Unir ambos datasets
combined_data <- rbind(
  data.frame(TieneInternet = "Sí", PUNT_GLOBAL = con_computadora$PUNT_GLOBAL),
  data.frame(TieneInternet = "No", PUNT_GLOBAL = sin_computadora$PUNT_GLOBAL)
)

# Graficar los puntajes de los dos grupos en un solo gráfico de caja
ggplot(combined_data, aes(x = TieneInternet, y = PUNT_GLOBAL, fill = TieneInternet)) +
  geom_boxplot() +
  labs(title = "Puntajes según el acceso a Internet",
       x = "Tiene Internet",
       y = "Puntaje global") +
  theme_minimal()

# Calcular correlación entre puntajes y tener computadora
correlacion_con <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENEINTERNET == "Si"))

# Calcular correlación entre puntajes y tener computadora
correlacion_sin <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENEINTERNET == "No"))

# Mostrar la correlación
cat("La correlación entre tener Internet y el puntaje es:", correlacion_con)

cat("La correlación entre no tener Internet y el puntaje es:", correlacion_sin)
```


### Uso de tiempo {.tabset}

#### Tiempo dedicado a Internet
```{r c_des_dint}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$dedicacion_internet <- factor(matrix_df$dedicacion_internet, levels = c(1, 2, 3, 4),
                                   labels = c("No Navega Internet", "30 minutos o menos", "Entre 1 y 3 horas", "Más de 3 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = dedicacion_internet, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo dedicado a Internet",
       x = "Tiempo en Internet",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$dedicacion_internet))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a Internet y el puntaje es:", correlacion)

```

#### Tiempo dedicado a leer 

¿Hay alguna relación entre el tiempo dedicado a leer y sus puntajes? 

```{r c_des_dlec}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$lectura_diaria <- factor(matrix_df$lectura_diaria, levels = c(1, 2, 3, 4, 5),
                                   labels = c("No leo por entretenimiento", "30 minutos o menos",
                                              "Entre 1 y 2 horas", "Entre 30 y 60 minutos",
                                              "Más de 2 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = lectura_diaria, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo de lectura diaria",
       x = "Tiempo de lectura",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$lectura_diaria))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a leer y el puntaje es:", correlacion)

```

#### Tiempo dedicado a trabajar
```{r c_des_dtrab}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$horas_trabajo <- factor(matrix_df$horas_trabajo, levels = c(1, 2, 3, 4, 5),
                                   labels = c("0", "Menos de 10 horas", "Entre 11 y 20 horas", "Entre 21 y 30 horas", "Más de 30 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = horas_trabajo, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo de trabajo semanal",
       x = "Tiempo de trabajo",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$horas_trabajo))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a trabajar en la semana y el puntaje es:", correlacion)

```
Lo siguiente muestra si los estudiantes que dijeron que trabajaban reciben pago o no.
Se hace un nuevo dataframe filtrando por los estudiantes que trabajan y a este nuevo dataframe
se le agrega una nueva columna 'Tipo_Remuneracion_Agrupado donde se agrupan los
que reciben paga en efectivo, especie o ambas, el otro valor en esta columna es 'No'

```{r c_des_dtrab_2}
# Mapear los valores numéricos a sus etiquetas correspondientes para tipo de remuneración
matrix_df$tipo_remuneracion <- factor(matrix_df$tipo_remuneracion, levels = c(1, 2, 3, 4),
                                   labels = c("No", "Si, en efectivo", "Si, en efectivo y especie", "Si, en especie"))

# Agrupar los estudiantes por tipo de remuneración
trabajo_mas_20_horas <- matrix_df %>%
  filter(horas_trabajo %in% c("Menos de 10 horas","Entre 11 y 20 horas","Entre 21 y 30 horas", "Más de 30 horas")) %>%
  mutate( # Filtrar estudiantes que trabajan entre 21 y 30 horas y más de 30 horas
    Tipo_Remuneracion_Agrupado = case_when(
      tipo_remuneracion %in% c("Si, en efectivo", "Si, en efectivo y especie", "Si, en especie") ~ "Sí, en efectivo, especie o ambas",
      TRUE ~ tipo_remuneracion  # Mantener otros valores sin modificar
    )
  )

# Crear el diagrama de barras para el tipo de remuneración
ggplot(trabajo_mas_20_horas, aes(x = Tipo_Remuneracion_Agrupado)) +
  geom_bar() +
  labs(title = "¿Usted recibe algún tipo de remuneración por trabajar?",
       x = "Tipo de remuneración",
       y = "Cantidad de estudiantes")
```

### Análisis demografico {.tabset}

Para este análisis, correspondiente a el mapeo de los promedios de puntajes por departamentos y municipios, se lleva a cabo:
La carga de los mapas corresponientes a departamentos y municipios.
Separación de datos y cálculo de media del puntaje por departamento o municipio respectivamente.
arreglo de datos, eliminando casos especiales y cambiando nombres de columnas y tipos de datos.
JOIN entre el mapa y los puntajes.
graficación.

#### Promedio de notas en deptos y municipio
<<<<<<< Updated upstream
```{r Promedio de notas en los departamentos de Colombia y municipios de Santander}
library(sf) # trabajar con los tipos de datos geográficos
library(dplyr) # realizar JOIN
library(tmap) # graficar mapas

=======
```{r Promedio de notas en los departamentos de Colombia y municipios de Santander, eval=FALSE}
>>>>>>> Stashed changes
## Cargando el mapa respectivo
map <- st_read("MGN2022_DPTO_POLITICO/MGN_DPTO_POLITICO.shp")
map2 <- map[,1] # Solo el mapa en terminos de su codigo

## Separando y arreglando los datos de interes de "data"

Puntaje.Depto<-aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_DEPTO, FUN = mean, data = data)

Puntaje.Depto=Puntaje.Depto[-34,]
colnames(Puntaje.Depto) <- c('DPTO_CCDGO','PUNTAJE')

map2$DPTO_CCDGO <- as.numeric(map2$DPTO_CCDGO)

## Uniendo tablas
mapJoin <- left_join(map2, Puntaje.Depto)

## Graficando
qtm(mapJoin,"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,280), fill.palette = c("red", "yellow", "green")) # Para todo el pais

#MUNICIPIOS

## Cargando el mapa respectivo
map <- st_read("MGN2022_MPIO_POLITICO/MGN_MPIO_POLITICO.shp")
map2 <- map[,1,3] # Solo el mapa en terminos de su codigo
#plot(map2)

## Separando y arreglando los datos de interes de "data"
Puntaje.MPIO<-aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_MCPIO, FUN = mean, data = data)

Puntaje.MPIO=Puntaje.MPIO[-1118,]
colnames(Puntaje.MPIO) <- c('MPIO_CDPMP','PUNTAJE')

colnames(map2) <- c('MCPIO_CCDGO','geometry')
Puntaje.MPIO$MPIO_CDPMP <- as.character(Puntaje.MPIO$MPIO_CDPMP)

## Uniendo tablas
mapJoin <- left_join(map, Puntaje.MPIO)

## Graficando
tmap_options(check.and.fix = TRUE)
qtm(mapJoin[mapJoin$DPTO_CCDGO =="68",],"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,280,300), fill.palette = c("red", "yellow", "green")) # Para todo el pais

```

#### Comparacion zonas urbanas y rurales 
<<<<<<< Updated upstream
```{r Mapeo de promedio de colegios en zona urbana y rural}
=======
```{r Mapeo de promedio de colegios en zona urbana y rural, eval=FALSE}
>>>>>>> Stashed changes
## Separando datos Urbano/Rural
dataUrbano <- data[data$COLE_AREA_UBICACION=="URBANO",]
dataRural <- data[data$COLE_AREA_UBICACION=="RURAL",]

## Areglando datos
Puntaje.Urbano <- aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_DEPTO, FUN = mean, data = dataUrbano)
Puntaje.Rural <- aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_DEPTO, FUN = mean, data = dataRural)

Puntaje.Urbano=Puntaje.Urbano[-34,]
colnames(Puntaje.Urbano) <- c('DPTO_CCDGO','PUNTAJE')
colnames(Puntaje.Rural) <- c('DPTO_CCDGO','PUNTAJE')

map <- st_read("MGN2022_DPTO_POLITICO/MGN_DPTO_POLITICO.shp")
map2 <- map[,1] # Solo el mapa en terminos de su codigo
map2$DPTO_CCDGO <- as.numeric(map2$DPTO_CCDGO)

## Uniendo tablas
mapJoinUrbano <- left_join(map2, Puntaje.Urbano)
mapJoinRural <- left_join(map2, Puntaje.Rural)

## Graficando
qtm(mapJoinUrbano,"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,280), fill.palette = c("red", "yellow", "green")) # Para todo el pais
qtm(mapJoinRural,"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,300), fill.palette = c("red", "yellow", "green")) # Para todo el pais

```
## Conclusiones
<<<<<<< Updated upstream
## Referencias
=======
## Referencias
>>>>>>> Stashed changes
