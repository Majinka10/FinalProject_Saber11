---
title: "Proyecto Final"
author: "Guillermo Pinto, Carlos García, Jesús Ramírez"
date: "2023-12-02"
output:         
    html_document:      
        code_folding: show      
editor_options: 
  markdown: 
    wrap: 72
encoding: UTF-8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# Pruebas Icfes Saber 11 del segundo semestre del año 2022 {.tabset}

## Introducción

En el contexto educativo actual, comprender los factores que influyen en
el rendimiento académico de los estudiantes es fundamental, por esta
razón, el proyecto se centra en investigar y analizar en profundidad los
determinantes detrás de los resultados obtenidos en las pruebas Saber
11. Este examen nacional es un referente clave en la evaluación del
sistema educativo, y explorar los elementos que impactan estos
resultados puede ofrecer valiosas perspectivas para mejorar el proceso
educativo.

Conforme a ello, el análisis se basará en un conjunto de datos de las
pruebas Saber 11 2022-2, que contiene información sobre los siguientes
aspectos de los estudiantes:

* Socioeconómico: estrato socioeconómico, nivel educativo de los padres,
ingresos familiares, etc. 

* Demográfico: región, género, etnia, etc.

* Académico: rendimiento en las pruebas Saber 11, asistencia escolar, etc.

* Familiar: estructura familiar, apoyo parental, etc.


## Paquetes requeridos 

Para reproducir el código y los resultados a lo largo de este proyecto, fue necesario cargar los siguientes paquetes.

- **knitr:** Se utiliza para mostrar una tabla alineada en la pantalla.
- **DT**: Útil para mostrar datos tabulares de una manera interactiva y configurable, facilitando la exploración y el análisis de los datos.
- **ggplot2**: Potente para visualizaciones, permite crear una amplia gama de gráficos personalizados y de alta calidad.

``` {r packages, eval= FALSE}
library(knitr)
library(DT)
library(ggplot2) # visualizing data
library(sf) # trabajar con tipos de datos geográficos
library(dplyr) # realizar JOIN
library(tmap) # graficar mapas
```



## Preparación de datos {.tabset .tabset-fade}

### Importación de datos

#### Resultados anonimizados de las pruebas Icfes Saber 11 del segundo semestre del año 2022.

El propósito original de los datos es proporcionar información valiosa y
oportuna sobre estudiantes que participan en las pruebas Saber,
incluyendo sus resultados académicos y datos socioeconómicos. Estos
datos, publicados por el Instituto Colombiano para la Evaluación de la
Educación (Icfes) en el repositorio DataIcfes, buscan contribuir al
mejoramiento de la calidad educativa en Colombia al ofrecer información
confiable y pertinente para análisis e investigaciones que incidan
positivamente en el sistema educativo del país.

Los datos se recopilan principalmente el día que los estudiantes
presentan la prueba. A partir de las respuestas proporcionadas en el
cuestionario sociodemográfico y las cinco pruebas en cada área del
conocimiento, se recopila información personal, de contacto, familiar,
así como datos del colegio y de citación. Los resultados, que incluyen
puntajes, percentiles y niveles socioeconómicos, se calculan con base en
los datos recolectados durante la presentación de las pruebas.

Este conjunto de datos abarca 82 variables que capturan una amplia gama
de factores socioeconómicos, demográficos y académicos a lo largo de
532,792 registros. Proporciona información sobre el rendimiento
académico, antecedentes familiares, instituciones educativas y puntajes
de pruebas entre estudiantes, cubriendo una amplia gama de contextos
socioeducativos. Además, ofrece información detallada sobre ubicaciones
geográficas, distribución de género y acceso a recursos dentro de
diversas comunidades.

Se puede incontrar más información sobre el conjunto de datos en la
página del Instituto Colombiano para la Evaluación de la Educación -
ICFES (2023). *DataIcfes. Saber 11.*
<https://www.icfes.gov.co/web/guest/data-icfes>

Nuestra exploración de datos inició con la tabla inicial provista por
[Datos.gov.co](https://www.datos.gov.co/Educaci-n/Saber-11-2019-2/ynam-yc42#),
revelando una estructura compleja y columnas poco claras. Accedimos al
diccionario de datos a través de DataIcfes, una base independiente del
Icfes. Tras solicitar acceso, encontramos información extensa sobre
pruebas Saber 11 desde 2001 hasta 2022 y escogimos los datos más
actualizados. A pesar de intentos fallidos de importar archivos .txt en
R debido al separador '¬', optamos por LibreOffice Calc para
convertirlos a CSV con separador ','. Posteriormente, logramos importar
con éxito en R usando read.csv, facilitando nuestro análisis.

```{r import_data}
ruta_datos <- "SB11_20222.csv"
data <- read.csv(ruta_datos, sep = ",", dec = ".", header = TRUE, stringsAsFactors = TRUE)

# Verificar la clase del objeto
class(data)
# Ver los nombres de las columnas
colnames(data)
# Contar la cantidad de registros y columnas
dim(data)
```

### Limpieza de datos

#### Datos irrelevantes

La limpieza de datos es crucial para garantizar la precisión y
coherencia en el análisis. Nuestro proceso de limpieza se basó en pasos
lógicos y específicos. Primero, identificamos columnas irrelevantes para
nuestro análisis, eliminándolas para focalizarnos en datos pertinentes.

Las columnas eliminadas abarcaban detalles específicos y contextuales
poco relevantes para nuestro análisis. Incluían información sobre la
estructura familiar, ocupación de los padres, alimentación y cantidad de habitaciones en el hogar, así como datos relacionados con el tipo de documento, nacionalidad, género, período de presentación del examen, entre otros.

Estos detalles, aunque podrían ser importantes en otros contextos, no
aportaban directamente a nuestras investigaciones sobre la correlación
entre variables socioeducativas, demográficas y el rendimiento académico. 
Su exclusión nos permitió concentrarnos en datos más pertinentes y directamente vinculados a nuestras áreas de estudio, optimizando así la calidad y relevancia de nuestro análisis.

```{r clean_data}
columnas_relevantes <- c(
    "ESTU_NSE_INDIVIDUAL", "PUNT_GLOBAL", "FAMI_TIENECOMPUTADOR",
    "FAMI_ESTRATOVIVIENDA", "COLE_NATURALEZA",
    "ESTU_DEDICACIONLECTURADIARIA", "ESTU_HORASSEMANATRABAJA",
    "FAMI_EDUCACIONPADRE", "FAMI_EDUCACIONMADRE", "FAMI_NUMLIBROS",
    "ESTU_DEDICACIONLECTURADIARIA", "FAMI_TIENECOMPUTADOR", "FAMI_TIENEINTERNET",
    "ESTU_DEDICACIONINTERNET", "DESEMP_LECTURA_CRITICA", "DESEMP_MATEMATICAS",
    "DESEMP_C_NATURALES", "DESEMP_SOCIALES_CIUDADANAS", "DESEMP_INGLES",
    "ESTU_COD_RESIDE_DEPTO", "ESTU_COD_RESIDE_MCPIO", "PUNT_INGLES",
    "PUNT_LECTURA_CRITICA", "PUNT_MATEMATICAS", "PUNT_C_NATURALES",
    "PUNT_SOCIALES_CIUDADANAS", "COLE_AREA_UBICACION"
)

data <- data[, columnas_relevantes, drop = FALSE]
```

___

Después de la limpieza de datos, volvemos a comprobar el número de filas
y columnas, como se muestra en el siguiente código.

```{r size_clean_data}
# Contar la cantidad de registros y columnas
dim(data)
```

___

#### Missing values

Además, al buscar correlaciones entre variables socioeducativas y
rendimiento académico, detectamos que algunos campos contenían valores
'NA' o vacíos.

Probamos eliminar 'NA' de manera general, pero resultó en la pérdida
significativa de datos, reduciendo el conjunto de más de 500K a poco más
de 7K registros, lo cual es poco representativo.

Decidimos, por ende, abordar esta limpieza de 'NA' de manera más
específica, es decir, eliminando los 'NA' solo de las columnas que
intervengan en resolución de una pregunta en particular. Por ejemplo, si
se analiza la correlación entre el puntaje obtenido y el nivel
socioeconómico del estudiante, solo se eliminan los 'NA' de estas dos
columnas para responder a la pregunta.

Esto nos permitió conservar un tamaño de muestra más representativo y
relevante para nuestros análisis sin sacrificar información crucial.
Esta metodología se alinea con el objetivo de garantizar que los datos
sean lo más precisos y completos posible para abordar las interrogantes
planteadas sin comprometer la integridad del análisis.

```{r missing_values}
# Contar la cantidad de NA
sum(is.na(data))

data <- data[complete.cases(data), ] # Quitar los NA del nuevo dataframe

sum(is.na(data))
```

### Previsualización de datos

#### Vista previa del conjunto de datos limpio

En los datos, cada fila es un estudiante y las columnas son la
información socioeconómica, demográfica, académica,  y familiar de la
prueba sobre el estudiante.

```{r prev_data}
library(DT)
datatable(head(data[, 1:10],50))
```

### Descripción de datos

```{r data_desc}
Variable.type <- lapply(data,class)
Variable.desc <- c(
    "¿Pertenece usted a un grupo étnico minoritario?",
    "Departamento de residencia",
    "Código Dane del departamento de residencia",
    "Municipio de Residencia",
    "Código Dane del municipio de residencia",
    "Nivel educativo más alto alcanzado por el padre",
    "Nivel educativo más alto alcanzado por la madre",
    "Estrato socioeconómico de la vivienda según recibo de energía eléctrica",
    "¿Su hogar cuenta con servicio o conexión a internet?",
    "¿Cuáles de los siguientes bienes posee su hogar?: Computador",
    "¿Cuáles de los siguientes bienes posee su hogar?: Máquina lavadora de ropa",
    "¿Cuáles de los siguientes bienes posee su hogar?: Horno Microondas u Horno eléctrico o a gas",
    "¿Su hogar cuenta con servicio cerrado de televisión?",
    "¿Cuáles de los siguientes bienes posee su hogar?: Automóvil particular",
    "¿Cuáles de los siguientes bienes posee su hogar?: Motocicleta",
    "¿Cuáles de los siguientes bienes posee su hogar?: Consola para juegos electrónicos (PlayStation, Xbox, Nintendo, etc.)",
    "¿Cuántos libros físicos o electrónicos hay en su hogar excluyendo periódicos, revistas, directorios telefónicos y libros del colegio?",
    "Usualmente, ¿cuánto tiempo al día dedica a leer por entretenimiento?",
    "Usualmente, ¿cuánto tiempo al día dedica a navegar en internet? Excluya actividades académicas",
    "¿Cuántas horas trabajó usted durante la semana pasada?",
    "¿Usted recibe algún tipo de remuneración por trabajar?",
    "Con respecto al año inmediatamente anterior, la situación económica de su hogar es:",
    "Indica la naturaleza del Establecimiento (Privado o público)",
    "Indica si el Establecimiento es bilingüe o no",
    "Área de ubicación de la Sede (rural o urbano)",
    "Código Dane del municipio donde está ubicada la Sede",
    "Nombre del municipio donde está ubicada la Sede",
    "Código Dane del departamento de la Sede",
    "Nombre del departamento donde está ubicada la Sede",
    "Desempeño matemáticas",
    "Desempeño en inglés",
    "Desempeño ciencias naturales",
    "Desempeño en lectura crítica",
    "Desempeño sociales y ciudadanas",
    "Puntaje total obtenido",
    "Percentil global en que se encuentra el evaluado",
    "Nivel Socioeconómico del evaluado",
    "Nivel Socioeconómico del Establecimiento"
)
data.desc <- as.data.frame(cbind(Data.Type = unlist(Variable.type), 
                                 Variable.Description = Variable.desc))
colnames(data.desc) <- c("Data Type","Variable Description")
library(knitr)
kable(data.desc)
```


## Análisis exploratorio {.tabset .tabset-fade}
### Matriz de correlación

Este código realiza la conversión de variables categóricas (factores) a numéricas, simplificando las etiquetas para mejorar la legibilidad y permitir el análisis estadístico.

Primero, identifico los niveles de las variables categóricas a convertir, mostrándolos para su inspección. Luego, reordeno estos niveles para asignarles un orden lógico, donde los valores inferiores tienen asignados números menores. Por ejemplo, en la variable de estrato socioeconómico, se asigna el número 1 al estrato más bajo y así sucesivamente. 

```{r factor_to_numeric}
# Conversión de variables factoriales a numéricas

## Primero se ven los niveles que tiene la variable
levels(data$FAMI_ESTRATOVIVIENDA)

## Luego se ordenan los niveles de menor a mayor
data$FAMI_ESTRATOVIVIENDA <- factor(data$FAMI_ESTRATOVIVIENDA, levels = c("Sin Estrato", "Estrato 1", "Estrato 2", "Estrato 3", "Estrato 4", "Estrato 5", "Estrato 6"))

## Se verifica
levels(data$FAMI_ESTRATOVIVIENDA)

## Se convierte a numero, donde 1 es el nivel inferior, así sucesivamente
data$FAMI_ESTRATOVIVIENDA <- as.numeric(data$FAMI_ESTRATOVIVIENDA)
```

Esto se hace para variables como dedicación diaria a la lectura, horas de trabajo, nivel educativo de los padres, número de libros en el hogar y tiempo de dedicación a internet.

```{r factor_to_numeric_resto, echo = TRUE, collapse = TRUE}
### Para tiempo de lectura diaria por entretenimiento
#levels(data$ESTU_DEDICACIONLECTURADIARIA)
data$ESTU_DEDICACIONLECTURADIARIA <- factor(data$ESTU_DEDICACIONLECTURADIARIA, levels = c("No leo por entretenimiento", "30 minutos o menos", "Entre 1 y 2 horas", "Entre 30 y 60 minutos", "Más de 2 horas"))
#levels(data$ESTU_DEDICACIONLECTURADIARIA)
data$ESTU_DEDICACIONLECTURADIARIA <- as.numeric(data$ESTU_DEDICACIONLECTURADIARIA)

### Para horas que trabaja
#levels(data$ESTU_HORASSEMANATRABAJA)
data$ESTU_HORASSEMANATRABAJA <- factor(data$ESTU_HORASSEMANATRABAJA, levels = c("0", "Menos de 10 horas", "Entre 11 y 20 horas", "Entre 21 y 30 horas", "Más de 30 horas"))
#levels(data$ESTU_HORASSEMANATRABAJA)
data$ESTU_HORASSEMANATRABAJA <- as.numeric(data$ESTU_HORASSEMANATRABAJA)

### Para educacion madre
#levels(data$FAMI_EDUCACIONMADRE)
data$FAMI_EDUCACIONMADRE <- factor(data$FAMI_EDUCACIONMADRE, levels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))
#levels(data$FAMI_EDUCACIONMADRE)
data$FAMI_EDUCACIONMADRE <- as.numeric(data$FAMI_EDUCACIONMADRE)

### Para educacion padre
#levels(data$FAMI_EDUCACIONPADRE)
data$FAMI_EDUCACIONPADRE <- factor(data$FAMI_EDUCACIONPADRE, levels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))
#levels(data$FAMI_EDUCACIONPADRE)
data$FAMI_EDUCACIONPADRE <- as.numeric(data$FAMI_EDUCACIONPADRE)

### Para numero de libros
#levels(data$FAMI_NUMLIBROS)
data$FAMI_NUMLIBROS <- factor(data$FAMI_NUMLIBROS, levels = c("0 A 10 LIBROS", "11 A 25 LIBROS", "26 A 100 LIBROS", "MÁS DE 100 LIBROS"))
#levels(data$FAMI_NUMLIBROS)
data$FAMI_NUMLIBROS <- as.numeric(data$FAMI_NUMLIBROS)

### Para tiempo de dedicacion internet
#levels(data$ESTU_DEDICACIONINTERNET)
data$ESTU_DEDICACIONINTERNET <- factor(data$ESTU_DEDICACIONINTERNET, levels = c("No Navega Internet", "30 minutos o menos", "Entre 1 y 3 horas", "Más de 3 horas"))
#levels(data$ESTU_DEDICACIONINTERNET)
data$ESTU_DEDICACIONINTERNET <- as.numeric(data$ESTU_DEDICACIONINTERNET)
```

Después de la conversión, creé un nuevo dataframe que incluye estas variables numéricas junto con otras variables relevantes como puntajes globales, desempeño en inglés, lectura crítica, matemáticas, ciencias y sociales. Además, se verifico y corrijo la presencia de valores perdidos (NA) en el nuevo dataframe, eliminándolos para garantizar una análisis robusto.

```{r cor_matrix}
matrix_df <- data[, c("FAMI_ESTRATOVIVIENDA", "ESTU_DEDICACIONLECTURADIARIA", "ESTU_HORASSEMANATRABAJA", "FAMI_EDUCACIONMADRE", "FAMI_EDUCACIONPADRE", "FAMI_NUMLIBROS", "ESTU_DEDICACIONINTERNET",  "ESTU_NSE_INDIVIDUAL", "PUNT_GLOBAL", "PUNT_INGLES", "DESEMP_LECTURA_CRITICA", "DESEMP_MATEMATICAS", "DESEMP_C_NATURALES", "DESEMP_SOCIALES_CIUDADANAS")]

sum(is.na(matrix_df)) # Contar los NA

matrix_df <- matrix_df[complete.cases(matrix_df), ] # Quitar los NA del nuevo dataframe

# Cambiar los nombres de las columnas para una matrix más legible
colnames(matrix_df) <- c("estrato", "lectura_diaria", "horas_trabajo", "educacion_madre", "educacion_padre", "num_libros", "dedicacion_internet", "nivel_socioeconomico","punt_global", "punt_ingles", "desempenio_lectura", "desempenio_mate", "desempenio_ciencias", "desempenio_sociales")

correlation_matrix <- cor(matrix_df)

# Generar el gráfico sin valores de correlación
corrplot::corrplot(correlation_matrix, type = "lower", tl.cex=0.7)
```

#### Qué se observa

- Se evidencia que la educación de los padres tiende a ser mayor conforme el estrato y que eso mismo se ve reflejados en puntajes un poco más altos de forma global y más específicamente en un mayor puntaje en inglés.
- Sacar más puntaje en un área específica tiene una correlación directa con sacar más puntaje en las demás áreas y sobre todo en el puntaje global como es obvio.
- Se observa una leve correlación entre la cantidad de libros y el puntaje. Aunque entre la cantidad de libros y la dedicación a leer no. Es extraño.

### Análisis socioeconómico {.tabset}

Se analiza la correlación entre varias variables, como el nivel socieconomico, el tipo de colegio (público/privado) o (bilingüe/no bilingüe), tiempo de dedicación a la lectura, el nivel educativo de los padres y el puntaje obtenido por los estudiantes.

#### Nivel socioeconómico 

Analizamos si existe una correlación entre el desempeño académico y el nivel socioeconómico del estudiante.

Para ello, lo primero que debemos hacer es crear un dataframe con las dos variables a analizar en este caso: "ESTU_NSE_INDIVIDUAL" y "PUNT_GLOBAL":

```{r c_des_nse}
library(ggplot2)
library(dplyr)

des_nse_df <- data[, c("ESTU_NSE_INDIVIDUAL", "PUNT_GLOBAL")] # Crear un nuevo dataframe con las dos columnas de interés

# Calcular correlación entre las dos variables
correlation_value <- cor(des_nse_df$ESTU_NSE_INDIVIDUAL, des_nse_df$PUNT_GLOBAL)
# Imprimir el valor de correlación
print(paste("La correlación entre NSE e PUNT_GLOBAL es:", round(correlation_value, 3)))
```
 Seguido de esto procedemos a realizar un histograma entre las dos variables, para analizar tendencias a partir del mismo: 
 
```{r c_des_nse_2}
# Gráfico combinado con líneas de densidad ajustadas por clase socioeconómica
ggplot(data, aes(x = PUNT_GLOBAL, fill = as.factor(ESTU_NSE_INDIVIDUAL))) +
  geom_density(alpha = 0.6, adjust = 1) +
  labs(title = "Distribución de puntajes por nivel socioeconómico", x = "Puntaje global", y = "Densidad") +
  scale_fill_discrete(name = "Nivel socioeconómico") +
  theme_minimal()
```

Del cual podemos concluir que


#### Tipo de colegio

Analizamos si el tipo de colegio (público/privado, bilingüe/no bilingüe) se correlaciona con el desempeño académico 

¿Los estudiantes de ciertos tipos de colegios tienen ventajas o desventajas en sus puntajes?

```{r c_des_tc}
library(ggplot2)
library(tidyr)
# Calcular el promedio de puntajes por tipo de colegio
promedios <- data %>%
  group_by(COLE_NATURALEZA) %>%
  summarise(
    Promedio_Lectura = mean(PUNT_LECTURA_CRITICA),
    Promedio_Matematicas = mean(PUNT_MATEMATICAS),
    Promedio_Ciencias = mean(PUNT_C_NATURALES),
    Promedio_Ingles = mean(PUNT_INGLES),
    Promedio_Sociales = mean(PUNT_SOCIALES_CIUDADANAS)
  )

# Reorganizar los datos para el gráfico de barras apiladas
stacked_data <- promedios %>%
  pivot_longer(cols = starts_with("Promedio"), names_to = "Area", values_to = "Promedio")

# Crear el gráfico de barras apiladas
ggplot(stacked_data, aes(x = COLE_NATURALEZA, y = Promedio, fill = Area)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = round(Promedio, 2)), 
            position = position_stack(vjust = 0.5), 
            color = "white", size = 4) +
  labs(title = "Desempeño promedio por área y tipo de colegio",
       x = "Tipo de colegio",
       y = "Puntaje promedio") +
  theme_minimal() +
  theme(legend.position = "right")

```


#### Nivel educativo de los padres

¿Los hijos de padres con niveles educativos más altos tienden a obtener mejores puntajes en las pruebas?

```{r c_des_ne}
library(ggplot2)

# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$educacion_padre <- factor(matrix_df$educacion_padre, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                                   labels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

matrix_df$educacion_madre <- factor(matrix_df$educacion_madre, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                                   labels = c("Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa", "Técnica o tecnológica incompleta", "Técnica o tecnológica completa", "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

# Combinar las columnas en una sola para el gráfico
combined_df <- matrix_df %>%
  gather(key = "tipo_educacion", value = "nivel_educacion", educacion_padre, educacion_madre)

# Reordenar niveles de la columna 'nivel_educacion'
combined_df$nivel_educacion <- factor(combined_df$nivel_educacion,
                                      levels = c("Ninguno", "Primaria incompleta", "Primaria completa",
                                                 "Secundaria (Bachillerato) incompleta", "Secundaria (Bachillerato) completa",
                                                 "Técnica o tecnológica incompleta", "Técnica o tecnológica completa",
                                                 "Educación profesional incompleta", "Educación profesional completa", "Postgrado"))

# Crear el gráfico de caja
ggplot(combined_df, aes(x = nivel_educacion, y = punt_global, fill = tipo_educacion)) +
  geom_boxplot() +
  labs(title = "Relación entre educación de los padres y puntaje global",
       x = "Nivel de educación",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

```




### Acceso a recursos {.tabset}

#### Computador

```{r cor_tienepc_punt}
# Crear un nuevo dataframe con un índice para representar a los estudiantes
data$indice <- seq_along(data$PUNT_GLOBAL)

# Filtrar datos para quienes tienen y no tienen computadora
con_computadora <- data[data$FAMI_TIENECOMPUTADOR == "Si", ]
sin_computadora <- data[data$FAMI_TIENECOMPUTADOR == "No", ]

# Unir ambos datasets
combined_data <- rbind(
  data.frame(TieneComputadora = "Sí", PUNT_GLOBAL = con_computadora$PUNT_GLOBAL),
  data.frame(TieneComputadora = "No", PUNT_GLOBAL = sin_computadora$PUNT_GLOBAL)
)

# Graficar los puntajes de los dos grupos en un solo gráfico de caja
ggplot(combined_data, aes(x = TieneComputadora, y = PUNT_GLOBAL, fill = TieneComputadora)) +
  geom_boxplot() +
  labs(title = "Puntajes según el acceso a un computador",
       x = "Tiene computador",
       y = "Puntaje global") +
  theme_minimal()

# Calcular correlación entre puntajes y tener computadora
correlacion_con <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENECOMPUTADOR == "Si"))

# Calcular correlación entre puntajes y tener computadora
correlacion_sin <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENECOMPUTADOR == "No"))

# Mostrar la correlación
cat("La correlación entre tener computador y el puntaje es:", correlacion_con)

cat("La correlación entre no tener computador y el puntaje es:", correlacion_sin)
```

#### Internet

```{r c_internet_des}
# Crear un nuevo dataframe con un índice para representar a los estudiantes
data$indice <- seq_along(data$PUNT_GLOBAL)

# Filtrar datos para quienes tienen y no tienen computadora
con_computadora <- data[data$FAMI_TIENEINTERNET == "Si", ]
sin_computadora <- data[data$FAMI_TIENEINTERNET == "No", ]

# Unir ambos datasets
combined_data <- rbind(
  data.frame(TieneInternet = "Sí", PUNT_GLOBAL = con_computadora$PUNT_GLOBAL),
  data.frame(TieneInternet = "No", PUNT_GLOBAL = sin_computadora$PUNT_GLOBAL)
)

# Graficar los puntajes de los dos grupos en un solo gráfico de caja
ggplot(combined_data, aes(x = TieneInternet, y = PUNT_GLOBAL, fill = TieneInternet)) +
  geom_boxplot() +
  labs(title = "Puntajes según el acceso a Internet",
       x = "Tiene Internet",
       y = "Puntaje global") +
  theme_minimal()

# Calcular correlación entre puntajes y tener computadora
correlacion_con <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENEINTERNET == "Si"))

# Calcular correlación entre puntajes y tener computadora
correlacion_sin <- cor(data$PUNT_GLOBAL, as.numeric(data$FAMI_TIENEINTERNET == "No"))

# Mostrar la correlación
cat("La correlación entre tener Internet y el puntaje es:", correlacion_con)

cat("La correlación entre no tener Internet y el puntaje es:", correlacion_sin)
```


### Uso de tiempo {.tabset}

#### Tiempo dedicado a Internet
```{r c_des_dint}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$dedicacion_internet <- factor(matrix_df$dedicacion_internet, levels = c(1, 2, 3, 4),
                                   labels = c("No Navega Internet", "30 minutos o menos", "Entre 1 y 3 horas", "Más de 3 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = dedicacion_internet, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo dedicado a Internet",
       x = "Tiempo en Internet",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$dedicacion_internet))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a Internet y el puntaje es:", correlacion)

```

#### Tiempo dedicado a leer 

¿Hay alguna relación entre el tiempo dedicado a leer y sus puntajes? 

```{r c_des_dlec}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$lectura_diaria <- factor(matrix_df$lectura_diaria, levels = c(1, 2, 3, 4, 5),
                                   labels = c("No leo por entretenimiento", "30 minutos o menos",
                                              "Entre 1 y 2 horas", "Entre 30 y 60 minutos",
                                              "Más de 2 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = lectura_diaria, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo de lectura diaria",
       x = "Tiempo de lectura",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$lectura_diaria))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a leer y el puntaje es:", correlacion)

```

#### Tiempo dedicado a trabajar
```{r c_des_dtrab}
# Mapear los valores numéricos a sus etiquetas correspondientes
matrix_df$horas_trabajo <- factor(matrix_df$horas_trabajo, levels = c(1, 2, 3, 4, 5),
                                   labels = c("0", "Menos de 10 horas", "Entre 11 y 20 horas", "Entre 21 y 30 horas", "Más de 30 horas"))

# Crear el gráfico de caja
ggplot(matrix_df, aes(x = horas_trabajo, y = punt_global)) +
  geom_boxplot() +
  labs(title = "Distribución de puntajes por tiempo de trabajo semanal",
       x = "Tiempo de trabajo",
       y = "Puntaje global") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotar etiquetas x si es necesario

# Calcular correlación entre puntajes y tener computadora
correlacion <- cor(matrix_df$punt_global, as.numeric(matrix_df$horas_trabajo))

# Mostrar la correlación
cat("La correlación entre el tiempo dedicado a leer y el puntaje es:", correlacion)

```

### Análisis demografico {.tabset}

#### Promedio de notas en deptos y municipio
1. ¿Hay diferencia entre la media de puntajes obtenidos en distintos departamentos de Colombia?
2. ¿Que tanta diferencia hay entre municipios de Santander?

Para este análisis, correspondiente a el mapeo de los promedios de puntajes por departamentos y municipios, se lleva a cab
Cargar los mapas corresponientes a departamentos y municipios.
Separar los datos y cálcular la media del puntaje por departamento o municipio respectivamente.
Arreglar datos, eliminando casos especiales y cambiando nombres de columnas y tipos de datos.
JOIN entre el mapa y los puntajes.
Graficación.
```{r Promedio de notas en los departamentos de Colombia y municipios de Santander}
library(sf) # trabajar con tipos de datos geográficos
library(dplyr) # realizar JOIN
library(tmap) # graficar mapas

## Cargando el mapa respectivo
map_departamentos <- st_read("MGN2022_DPTO_POLITICO/MGN_DPTO_POLITICO.shp")
map_municipios <- st_read("MGN2022_MPIO_POLITICO/MGN_MPIO_POLITICO.shp")

## Separando y arreglando los datos de interés de "data"
Puntaje.Depto <- aggregate(PUNT_GLOBAL ~ ESTU_COD_RESIDE_DEPTO, FUN = mean, data = data)
Puntaje.Depto <- Puntaje.Depto[-34,]
colnames(Puntaje.Depto) <- c('DPTO_CCDGO', 'PUNTAJE')

Puntaje.MPIO <- aggregate(PUNT_GLOBAL ~ ESTU_COD_RESIDE_MCPIO, FUN = mean, data = data)
Puntaje.MPIO <- Puntaje.MPIO[-1118,]
colnames(Puntaje.MPIO) <- c('MPIO_CDPMP', 'PUNTAJE')

map_departamentos$DPTO_CCDGO <- as.numeric(map_departamentos$DPTO_CCDGO)
map_municipios$MPIO_CDPMP <- as.numeric(map_municipios$MPIO_CDPMP)
## Uniendo tablas
mapJoin_Depto <- left_join(map_departamentos, Puntaje.Depto)
mapJoin_MPIO <- left_join(map_municipios, Puntaje.MPIO)

## Graficando
tmap_options(check.and.fix = TRUE)
qtm(mapJoin_Depto,"PUNTAJE", fill.breaks = c(0, 200, 210, 220, 230, 240, 250, 260, 270, 280, 300), fill.palette = c("red", "yellow", "green"))
qtm(mapJoin_MPIO[mapJoin_MPIO$DPTO_CCDGO=="68",],"PUNTAJE", fill.breaks = c(0, 200, 210, 220, 230, 240, 250, 260, 270, 280, 300), fill.palette = c("red", "yellow", "green"))
```

#### Comparacion zonas urbanas y rurales 
¿Existe diferencia entre la educación en zonas urbanas y la educación en zonas rurales?

Siguiendo los lineamientos de la pregunta anterior, este analisis consiste en:
Separar los datos de los estudiantes en dos conjuntos de acuerdo a la zona (urbano y rural)
Quitar los datos no relevantes para la pregunta y dejar solo el departamento y la media del puntaje para cada conjunto de estudiantes
Hacer el JOIN
Graficar.
```{r Mapeo de promedio de colegios en zona urbana y rural}
## Separando datos Urbano/Rural
dataUrbano <- data[data$COLE_AREA_UBICACION=="URBANO",]
dataRural <- data[data$COLE_AREA_UBICACION=="RURAL",]

## Areglando datos
Puntaje.Urbano <- aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_DEPTO, FUN = mean, data = dataUrbano)
Puntaje.Rural <- aggregate(PUNT_GLOBAL~ESTU_COD_RESIDE_DEPTO, FUN = mean, data = dataRural)

Puntaje.Urbano=Puntaje.Urbano[-34,]
colnames(Puntaje.Urbano) <- c('DPTO_CCDGO','PUNTAJE')
colnames(Puntaje.Rural) <- c('DPTO_CCDGO','PUNTAJE')

## Uniendo tablas
mapJoinUrbano <- left_join(map_departamentos, Puntaje.Urbano)
mapJoinRural <- left_join(map_departamentos, Puntaje.Rural)

## Graficando
qtm(mapJoinUrbano,"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,280), fill.palette = c("red", "yellow", "green")) # Para todo el pais
qtm(mapJoinRural,"PUNTAJE", fill.breaks = c(0,200,210,220,230,240,250,260,270,300), fill.palette = c("red", "yellow", "green")) # Para todo el pais

```

### Correlación entre áreas de conocimiento

```{r c_puntajes}

nuevo_df_5 <- data[, c("PUNT_LECTURA_CRITICA", "PUNT_MATEMATICAS", "PUNT_C_NATURALES","PUNT_SOCIALES_CIUDADANAS","PUNT_INGLES")]

sum(is.na(nuevo_df_5)) # Contar la cantidad de NA

nuevo_df_limpiado_5 <- nuevo_df_5[complete.cases(nuevo_df_5), ] # Quitar los NA del nuevo dataframe

sum(is.na(nuevo_df_limpiado_5)) # Contar la cantidad de NA

matriz_correlacion <- cor(nuevo_df_limpiado_5[, c("PUNT_LECTURA_CRITICA", "PUNT_MATEMATICAS", "PUNT_C_NATURALES", "PUNT_SOCIALES_CIUDADANAS", "PUNT_INGLES")])

print(matriz_correlacion)

library(ggplot2)

ggplot(data = reshape2::melt(matriz_correlacion)) +
  geom_tile(aes(Var1, Var2, fill = value), color = "white") +
  scale_fill_gradient2(low = "red", mid = "white", high = "blue", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab",
                       name = "Correlation") +
  theme_minimal() +
  labs(title = "Matriz de correlación")
```

## Conclusiones

